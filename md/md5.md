---
title: 'MD5'
date: Thu, 15 Aug 2019 06:27:26 +0000
draft: false
tags: ['MD5', '密码学']
---

MD5消息摘要算法（MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。 MD5可以将任意长度的字节串变换成一个128位的散列值，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5摘要变换回原始的字符串。 MD5的典型应用是防止对信息串 (Message)的篡改。例如将一段话写在一个文本文件中，并对这个文本文件产生一个MD5值并记录在案，然后在传播这个文件的时候，别人如果修改了文件中的任何内容，使用者在对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。 MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的，用户登录的时候，系统把用户输入的密码计算成MD5值，然后去和数据库中保存的MD5值进行比较，而系统并不知道用户的密码是什么。原生的MD5已经被证实可以被碰撞破解，可以在CMD5上可以根据MD5密文查询出对应明文。对于需要高度安全性的数据，建议对原生MD5进行改进或改用其他算法。

算法
--

1.  待加密信息处理 由于MD5对任意长度的字节串生成的都是相同长度（128位）的摘要，所以首先需要对字符串进行处理。 我们知道一个字符的长度是一个字节，即8位（bit）的长度。MD5对待加密的字符串的处理是将一个字符串分割成每512位为一个分组，形如N\*512+R，这里的R是余下的位数，分为几种情况：
    *   R=0时，需要补位，单补上一个512位的分组，因为还要加入最后64个位的字符串长度。
    *   R<448时，则需要补位到448位，后面添加64位的字符串长度。
    *   R>448时，除了补满这一分组外，还要再补上一个512位的分组后面添加64位的字符串长度。 补位的方式是先填充一个1，然后填充0，直到补足512位。
2.  链接变量 MD5有四个32位的被称作链接变量的整数参数，这是个参数我们定义为A、B、C、D其取值为：```
    A=0x01234567，B=0x89abcdef，C=0xfedcba98，D=0x76543210
    ```
    
    但考虑到内存数据存储大小端的问题我们将其赋值为：
    
    ```
    A=0x67452301，B=0xefcdab89，C=0x98badcfe，D=0x10325476
    ```
3.  MD5算法规定了四个非线性操作函数（&是与，|是或，~是非，^是异或）：
    
    ```
    F(X, Y, Z) = ( X & Y ) | ( ( ~X ) & Z )
    G(X, Y, Z) = ( X & Z ) | ( Y & ( ~Z ) )
    H(X, Y, Z) = X ^ Y ^ Z
    I(X, Y, Z) = Y ^ ( X | ( ~Z ) )
    ```
    
    这些函数是这样设计的：如果X、Y\\Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。利用上面的四种操作，生成四个重要的计算函数。首先我们声明四个中间变量a,b,c,d，赋值：a = A, b = B, c = C, d = D。然后定义这四个计算函数为：
    
    ```
    FF(a, b, c, d, M[j], s, ti){
      a = b + ((a + F(b, c, d) + Mj + ti) <<< s)
    }
    GG(a, b, c, d, M[j], s, ti){
      a = b + ((a + G(b, c, d) + Mj + ti) <<< s)
    }
    HH(a, b, c, d, M[j], s, ti){
      a = b + ((a + H(b, c, d) + Mj + ti) <<< s)
    }
    II(a, b, c, d, M[j], s, ti){
      a = b + ((a + I(b, c, d) + Mj + ti) <<< s)
    }
    ```
    
    其中M\[j\]表示消息的第j个子分组（从0到15），<<<表示循环左移s，常数ti是`4294967296*abs(sin(i))`的整数部分，i取值从1到64，单位是弧度。
    
4.  计算
    
    ```
    //第一轮循环计算
    FF(a,b,c,d,M[0],7,0xd76aa478);
    FF(d,a,b,c,M[1],12,0xe8c7b756);
    FF(c,d,a,b,M[2],17,0x242070db);
    FF(b,c,d,a,M[3],22,0xc1bdceee);
    FF(a,b,c,d,M[4],7,0xf57c0faf);
    FF(d,a,b,c,M[5],12,0x4787c62a);
    FF(c,d,a,b,M[6],17,0xa8304613);
    FF(b,c,d,a,M[7],22,0xfd469501) ;
    FF(a,b,c,d,M[8],7,0x698098d8) ;
    FF(d,a,b,c,M[9],12,0x8b44f7af) ;
    FF(c,d,a,b,M[10],17,0xffff5bb1) ;
    FF(b,c,d,a,M[11],22,0x895cd7be) ;
    FF(a,b,c,d,M[12],7,0x6b901122) ;
    FF(d,a,b,c,M[13],12,0xfd987193) ;
    FF(c,d,a,b,M[14],17,0xa679438e) ;
    FF(b,c,d,a,M[15],22,0x49b40821);
    
    //第二轮循环计算
    GG(a,b,c,d,M[1],5,0xf61e2562);
    GG(d,a,b,c,M[6],9,0xc040b340);
    GG(c,d,a,b,M[11],14,0x265e5a51);
    GG(b,c,d,a,M[0],20,0xe9b6c7aa) ;
    GG(a,b,c,d,M[5],5,0xd62f105d) ;
    GG(d,a,b,c,M[10],9,0x02441453) ;
    GG(c,d,a,b,M[15],14,0xd8a1e681);
    GG(b,c,d,a,M[4],20,0xe7d3fbc8) ;
    GG(a,b,c,d,M[9],5,0x21e1cde6) ;
    GG(d,a,b,c,M[14],9,0xc33707d6) ;
    GG(c,d,a,b,M[3],14,0xf4d50d87) ;
    GG(b,c,d,a,M[8],20,0x455a14ed);
    GG(a,b,c,d,M[13],5,0xa9e3e905);
    GG(d,a,b,c,M[2],9,0xfcefa3f8) ;
    GG(c,d,a,b,M[7],14,0x676f02d9) ;
    GG(b,c,d,a,M[12],20,0x8d2a4c8a);
    
    //第三轮循环计算
    HH(a,b,c,d,M[5],4,0xfffa3942);
    HH(d,a,b,c,M[8],11,0x8771f681);
    HH(c,d,a,b,M[11],16,0x6d9d6122);
    HH(b,c,d,a,M[14],23,0xfde5380c) ;
    HH(a,b,c,d,M[1],4,0xa4beea44) ;
    HH(d,a,b,c,M[4],11,0x4bdecfa9) ;
    HH(c,d,a,b,M[7],16,0xf6bb4b60) ;
    HH(b,c,d,a,M[10],23,0xbebfbc70);
    HH(a,b,c,d,M[13],4,0x289b7ec6);
    HH(d,a,b,c,M[0],11,0xeaa127fa);
    HH(c,d,a,b,M[3],16,0xd4ef3085);
    HH(b,c,d,a,M[6],23,0x04881d05);
    HH(a,b,c,d,M[9],4,0xd9d4d039);
    HH(d,a,b,c,M[12],11,0xe6db99e5);
    HH(c,d,a,b,M[15],16,0x1fa27cf8) ;
    HH(b,c,d,a,M[2],23,0xc4ac5665);
    
    //第四轮循环计算
    II(a,b,c,d,M[0],6,0xf4292244) ;
    II(d,a,b,c,M[7],10,0x432aff97) ;
    II(c,d,a,b,M[14],15,0xab9423a7);
    II(b,c,d,a,M[5],21,0xfc93a039) ;
    II(a,b,c,d,M[12],6,0x655b59c3) ;
    II(d,a,b,c,M[3],10,0x8f0ccc92) ;
    II(c,d,a,b,M[10],15,0xffeff47d);
    II(b,c,d,a,M[1],21,0x85845dd1) ;
    II(a,b,c,d,M[8],6,0x6fa87e4f) ;
    II(d,a,b,c,M[15],10,0xfe2ce6e0);
    II(c,d,a,b,M[6],15,0xa3014314) ;
    II(b,c,d,a,M[13],21,0x4e0811a1);
    II(a,b,c,d,M[4],6,0xf7537e82) ;
    II(d,a,b,c,M[11],10,0xbd3af235);
    II(c,d,a,b,M[2],15,0x2ad7d2bb);
    II(b,c,d,a,M[9],21,0xeb86d391);
    ```
    
    处理完所有的512位的分组后，得到一组新的A,B,C,D的值，将这些值按ABCD的顺序级联，就得到了想要的MD5散列值。
    

其他
--

MD5本质上就是一种哈希算法，考虑到其不可逆性和稳定性，MD5有着广泛地应用。 2009年，中国科学院的谢涛和冯登国仅用了220.96的碰撞算法复杂度，破解了MD5的碰撞抵抗，该攻击在普通计算机上运行只需要数秒钟。因此在实际运用中可以采用用户名加盐、随机数加盐等方式加强安全性。